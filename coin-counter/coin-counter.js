/* eslint-disable fp/no-nil */
/// Most of this was written under the assumption that they would only be
/// accepting the change portion of any given value as an integer.
/// Ex: 2.99 => recursiveCounter(99);

/**
 * Determines the change to be returned that matches value.
 * @param {number} value - Integer from 0 to 99.
 * @returns {array} Coins from penny to quarter that match value.
 */
export const recursiveCounter = (value) => {
  // Would returning a default case be okay when passed in garbage values? How
  // would I communicate to the caller that what they've done is stupid? As I
  // wrote this I figured that's just not something that's done in JS.
  if (value < 1 || value > 99 || !Number.isInteger(value)) {
    return [0, 0, 0, 0];
  }

  // This feels dumb, but it works.
  return [
    countCoins(value, 25),
    countCoins(value % 25, 10),
    countCoins(value % 25 % 10, 5),
    countCoins(value % 25 % 10 % 5, 1)
  ];
};

// This is recursive, but it would be much easier to just write it as
// floor(v / c) and move on. Also does not check whether the values passed in
// are valid or not minus checking if coinValue is greater than value.
export const countCoins = (value, coinValue) => {
  if (coinValue > value) {
    return 0;
  } else {
    return countCoins(value - coinValue, coinValue) + 1;
  }
};

/******************************************************************************/

// this also feels dumb, but again it works
export const closureCounter = value => {
  const quarter = closureCountCoins(25);
  const dime = closureCountCoins(10);
  const nickel = closureCountCoins(5);
  const penny = closureCountCoins(1);

  return [
    quarter(value),
    dime(value % 25),
    nickel(value % 25 % 10),
    penny(value % 25 % 10 % 5)
  ];
};

export const closureCountCoins = coin => value => {
  if (!Number.isInteger(value) ||
      !Number.isInteger(coin) ||
      coin > value ||
      coin > 99 ||
      coin < 1 ||
      value > 99 ||
      value < 1) {
    return 0;
  } else {
    return Math.floor(value / coin);
  }
};

/******************************************************************************/

export const plainCounter = value => {
  if (value < 1 || value > 99 || !Number.isInteger(value)) {
    return [0, 0, 0, 0];
  }

  return [
    Math.floor(value / 25),
    Math.floor((value % 25) / 10),
    Math.floor((value % 25 % 10) / 5),
    Math.floor((value % 25 % 10 % 5))
  ];
};

/******************************************************************************/

// is this slow because i'm just returning immediately?
// notSoQuickCounter
// would it be faster to keep the values as strings and then split them?
// export const notSoQuickCounter = value => {
//   return [[ 0, 0, 0, 1 ],[ 0, 0, 0, 2 ],[ 0, 0, 0, 3 ],[ 0, 0, 0, 4 ],[ 0, 0, 1, 0 ],[ 0, 0, 1, 1 ],[ 0, 0, 1, 2 ],[ 0, 0, 1, 3 ],[ 0, 0, 1, 4 ],[ 0, 1, 0, 0 ],[ 0, 1, 0, 1 ],[ 0, 1, 0, 2 ],[ 0, 1, 0, 3 ],[ 0, 1, 0, 4 ],[ 0, 1, 1, 0 ],[ 0, 1, 1, 1 ],[ 0, 1, 1, 2 ],[ 0, 1, 1, 3 ],[ 0, 1, 1, 4 ],[ 0, 2, 0, 0 ],[ 0, 2, 0, 1 ],[ 0, 2, 0, 2 ],[ 0, 2, 0, 3 ],[ 0, 2, 0, 4 ],[ 1, 0, 0, 0 ],[ 1, 0, 0, 1 ],[ 1, 0, 0, 2 ],[ 1, 0, 0, 3 ],[ 1, 0, 0, 4 ],[ 1, 0, 1, 0 ],[ 1, 0, 1, 1 ],[ 1, 0, 1, 2 ],[ 1, 0, 1, 3 ],[ 1, 0, 1, 4 ],[ 1, 1, 0, 0 ],[ 1, 1, 0, 1 ],[ 1, 1, 0, 2 ],[ 1, 1, 0, 3 ],[ 1, 1, 0, 4 ],[ 1, 1, 1, 0 ],[ 1, 1, 1, 1 ],[ 1, 1, 1, 2 ],[ 1, 1, 1, 3 ],[ 1, 1, 1, 4 ],[ 1, 2, 0, 0 ],[ 1, 2, 0, 1 ],[ 1, 2, 0, 2 ],[ 1, 2, 0, 3 ],[ 1, 2, 0, 4 ],[ 2, 0, 0, 0 ],[ 2, 0, 0, 1 ],[ 2, 0, 0, 2 ],[ 2, 0, 0, 3 ],[ 2, 0, 0, 4 ],[ 2, 0, 1, 0 ],[ 2, 0, 1, 1 ],[ 2, 0, 1, 2 ],[ 2, 0, 1, 3 ],[ 2, 0, 1, 4 ],[ 2, 1, 0, 0 ],[ 2, 1, 0, 1 ],[ 2, 1, 0, 2 ],[ 2, 1, 0, 3 ],[ 2, 1, 0, 4 ],[ 2, 1, 1, 0 ],[ 2, 1, 1, 1 ],[ 2, 1, 1, 2 ],[ 2, 1, 1, 3 ],[ 2, 1, 1, 4 ],[ 2, 2, 0, 0 ],[ 2, 2, 0, 1 ],[ 2, 2, 0, 2 ],[ 2, 2, 0, 3 ],[ 2, 2, 0, 4 ],[ 3, 0, 0, 0 ],[ 3, 0, 0, 1 ],[ 3, 0, 0, 2 ],[ 3, 0, 0, 3 ],[ 3, 0, 0, 4 ],[ 3, 0, 1, 0 ],[ 3, 0, 1, 1 ],[ 3, 0, 1, 2 ],[ 3, 0, 1, 3 ],[ 3, 0, 1, 4 ],[ 3, 1, 0, 0 ],[ 3, 1, 0, 1 ],[ 3, 1, 0, 2 ],[ 3, 1, 0, 3 ],[ 3, 1, 0, 4 ],[ 3, 1, 1, 0 ],[ 3, 1, 1, 1 ],[ 3, 1, 1, 2 ],[ 3, 1, 1, 3 ],[ 3, 1, 1, 4 ],[ 3, 2, 0, 0 ],[ 3, 2, 0, 1 ],[ 3, 2, 0, 2 ],[ 3, 2, 0, 3 ],[ 3, 2, 0, 4 ]][value-1];
// };

const preComputedObj = { "1": [0,0,0,1], "2": [0,0,0,2], "3": [0,0,0,3], "4": [0,0,0,4], "5": [0,0,1,0], "6": [0,0,1,1], "7": [0,0,1,2], "8": [0,0,1,3], "9": [0,0,1,4], "10": [0,1,0,0], "11": [0,1,0,1], "12": [0,1,0,2], "13": [0,1,0,3], "14": [0,1,0,4], "15": [0,1,1,0], "16": [0,1,1,1], "17": [0,1,1,2], "18": [0,1,1,3], "19": [0,1,1,4], "20": [0,2,0,0], "21": [0,2,0,1], "22": [0,2,0,2], "23": [0,2,0,3], "24": [0,2,0,4], "25": [1,0,0,0], "26": [1,0,0,1], "27": [1,0,0,2], "28": [1,0,0,3], "29": [1,0,0,4], "30": [1,0,1,0], "31": [1,0,1,1], "32": [1,0,1,2], "33": [1,0,1,3], "34": [1,0,1,4], "35": [1,1,0,0], "36": [1,1,0,1], "37": [1,1,0,2], "38": [1,1,0,3], "39": [1,1,0,4], "40": [1,1,1,0], "41": [1,1,1,1], "42": [1,1,1,2], "43": [1,1,1,3], "44": [1,1,1,4], "45": [1,2,0,0], "46": [1,2,0,1], "47": [1,2,0,2], "48": [1,2,0,3], "49": [1,2,0,4], "50": [2,0,0,0], "51": [2,0,0,1], "52": [2,0,0,2], "53": [2,0,0,3], "54": [2,0,0,4], "55": [2,0,1,0], "56": [2,0,1,1], "57": [2,0,1,2], "58": [2,0,1,3], "59": [2,0,1,4], "60": [2,1,0,0], "61": [2,1,0,1], "62": [2,1,0,2], "63": [2,1,0,3], "64": [2,1,0,4], "65": [2,1,1,0], "66": [2,1,1,1], "67": [2,1,1,2], "68": [2,1,1,3], "69": [2,1,1,4], "70": [2,2,0,0], "71": [2,2,0,1], "72": [2,2,0,2], "73": [2,2,0,3], "74": [2,2,0,4], "75": [3,0,0,0], "76": [3,0,0,1], "77": [3,0,0,2], "78": [3,0,0,3], "79": [3,0,0,4], "80": [3,0,1,0], "81": [3,0,1,1], "82": [3,0,1,2], "83": [3,0,1,3], "84": [3,0,1,4], "85": [3,1,0,0], "86": [3,1,0,1], "87": [3,1,0,2], "88": [3,1,0,3], "89": [3,1,0,4], "90": [3,1,1,0], "91": [3,1,1,1], "92": [3,1,1,2], "93": [3,1,1,3], "94": [3,1,1,4], "95": [3,2,0,0], "96": [3,2,0,1], "97": [3,2,0,2], "98": [3,2,0,3], "99": [3,2,0,4] };

export const notSoQuickCounterObj = value => {
  if (value < 1 || value > 99 || !Number.isInteger(value)) {
    return [0, 0, 0, 0];
  }

  return preComputedObj[value];
};

const preComputedArr = [ [0,0,0,1], [0,0,0,2], [0,0,0,3], [0,0,0,4], [0,0,1,0], [0,0,1,1], [0,0,1,2], [0,0,1,3], [0,0,1,4], [0,1,0,0], [0,1,0,1], [0,1,0,2], [0,1,0,3], [0,1,0,4], [0,1,1,0], [0,1,1,1], [0,1,1,2], [0,1,1,3], [0,1,1,4], [0,2,0,0], [0,2,0,1], [0,2,0,2], [0,2,0,3], [0,2,0,4], [1,0,0,0], [1,0,0,1], [1,0,0,2], [1,0,0,3], [1,0,0,4], [1,0,1,0], [1,0,1,1], [1,0,1,2], [1,0,1,3], [1,0,1,4], [1,1,0,0], [1,1,0,1], [1,1,0,2], [1,1,0,3], [1,1,0,4], [1,1,1,0], [1,1,1,1], [1,1,1,2], [1,1,1,3], [1,1,1,4], [1,2,0,0], [1,2,0,1], [1,2,0,2], [1,2,0,3], [1,2,0,4], [2,0,0,0], [2,0,0,1], [2,0,0,2], [2,0,0,3], [2,0,0,4], [2,0,1,0], [2,0,1,1], [2,0,1,2], [2,0,1,3], [2,0,1,4], [2,1,0,0], [2,1,0,1], [2,1,0,2], [2,1,0,3], [2,1,0,4], [2,1,1,0], [2,1,1,1], [2,1,1,2], [2,1,1,3], [2,1,1,4], [2,2,0,0], [2,2,0,1], [2,2,0,2], [2,2,0,3], [2,2,0,4], [3,0,0,0], [3,0,0,1], [3,0,0,2], [3,0,0,3], [3,0,0,4], [3,0,1,0], [3,0,1,1], [3,0,1,2], [3,0,1,3], [3,0,1,4], [3,1,0,0], [3,1,0,1], [3,1,0,2], [3,1,0,3], [3,1,0,4], [3,1,1,0], [3,1,1,1], [3,1,1,2], [3,1,1,3], [3,1,1,4], [3,2,0,0], [3,2,0,1], [3,2,0,2], [3,2,0,3], [3,2,0,4] ];

export const notSoQuickCounterArr = value => {
  if (value < 1 || value > 99 || !Number.isInteger(value)) {
    return [0, 0, 0, 0];
  }

  // 0-indexed rather than 1-indexed
  return preComputedArr[value-1];
};
